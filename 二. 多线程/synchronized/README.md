#synchronized（from:https://www.imooc.com/learn/1086）
##两种用法
+ 第一个用法:对象锁  
    + 代码块形式:手动指定对象锁  
    + 方法锁形式：synchronized修饰普通方法，锁对象默认为this  
+ 第二个用法:类锁  
    + 概念：  
        + Java类可能有很多个对象,但只有1个Class对象  
        + 本质：所谓类锁，不过是Class对象的锁而已  
    + 形式：  
        + 1：synchronized加在static方法上  
        + 2：synchronized(*.class)代码块  


##七种面试常见问题
* 1.两个线程同时访问一个对象的同步方法  
* 2.两个线程访问的是两个对象的同步方法  
* 3.两个线程访问的是synchronized的静态方法  
* 4.同时访问同步方法和非同步方法  
* 5.访问的是同一个对象的不同的普通（非静态）同步方法  
* 6.同时访问静态synchronized和非静态synchronized方法  
* 7.方法抛出异常后，会释放锁  
##三种核心思想
* 1.一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待（对应1,5两种情况）  
* 2.每个实例都对应自己的一把锁，不同实例之间互不影响;例外：锁对象是*.class以及synchronized修饰的static方法的时候，  
    所有对象共用一把锁（对应2,3,4,6四中情况）  
* 3.无论是方法正常执行完毕或者方法抛出异常，都会释放锁（对应7这种情况）  


##性质
+ 1.可重入  
    同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁  
    + 好处
        * 避免死锁
        * 提升封装性  
    + 粒度（scope）：线程（pthread粒度为调用）  
        case 1：证明同一个方法是可重入的  
        case 2：证明可重入不要求是同一个方法
        case 3：证明可重入不要求是同一个类中的  
+ 2.不可中断  
    一旦这个锁被别的线程获取，如果本线程还想获得，只能选择等待或者阻塞，直到别的线程
    释放这个锁。如果别的线程永远不释放该锁，本线程只能永远等待
    
    + 相比之下，Lock类，可以拥有中断的能力
        + 1 有权中断现在已经获取到锁的线程的执行
        + 2 可以退出


##原理
+ 加锁和释放锁的原理
    + 现象
    + 时机  
        * 内置锁               
    + 深入JVM看字节码
        * monitorenter monitorexit(通过反编译含有synchronized同步代码块的.class 可查看;javap -verbose *.class) 
+ 可重入原理
    + 加锁次数计数器  
        * jvm负责跟踪对象被加锁的次数  
        * 线程第一次给对象加锁的时候，计数变为1.每当这个相同的线程在此对象上在此获得锁时,计数会递增  
        * 每当任务离开时，计数递减，当计数为0的时候，锁被完全释放
+ 保证可见性原理
    + 内存模型    
    
##缺陷    
+ 效率低
    * 锁的释放情况少
    * 试图获得锁时不能设定超时
    * 不能中断一个正在试图获得锁的线程 
+ 不够灵活（读写锁更灵活）
    * 加锁和释放锁的时机非常单一
    * 每个锁仅有一个单一的条件（某个对象），可能是不够的
+ 无法知道是否成功获取锁

##常见面试问题
+ 使用注意点：
    * 锁对象不能为空（锁的信息保存在对象头中）
    * 作用域不宜过大
    * 避免死锁     
+ 如何选择Lock和synchronized关键字(建议)
    * 尽量使用java.util.concurrent包的类
    * 如果synchronized关键字适用，优先使用synchronized关键字，减少编码，减少错误几率
    * 必须lock..condition，才lock..condition
+ 多线程访问同步方法的各种具体情况   
    * 对应上面的“七种面试常见问题”
    
##思考题
+ 多个线程等待同一个synchronized锁的时候，jvm如何选择下一个获取锁的是哪一个线程?
    * 内部锁调度机制
+ synchronized使得同时只有一个线程可以执行，性能较差，有什么办法可以提升性能？
    * 优化使用范围
    * 使用其他类型的lock
+ 想更加灵活地控制锁的获取和释放（现在释放锁的机制都被规定死了）,怎么办？
    * 自己实现Lock接口的实现类
+ 什么是锁的升级，降级？什么是JVM里的偏斜锁，轻量级锁，重量级锁？
    * 根据使用次数等情况，进行调整，以提高synchronized的性能      
    
##总结
+ 一句话介绍synchronized
    * JVM会自动通过使用monitor来加锁和解锁，保证了同时只有一个线程可以执行指定代码，
        从而保证了线程安全，同时具有可重入和不可中断的性质。      